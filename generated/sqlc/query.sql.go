// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO app_role_binding (role_id, user_id, org_id) 
VALUES ($1, $2, $3)
ON CONFLICT (user_id, org_id) 
DO UPDATE SET role_id = EXCLUDED.role_id
`

type AssignRoleToUserParams struct {
	RoleID int32
	UserID pgtype.UUID
	OrgID  pgtype.UUID
}

// RBAC
func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.RoleID, arg.UserID, arg.OrgID)
	return err
}

const createApiToken = `-- name: CreateApiToken :one
INSERT INTO app_api_token (org_id, name, token) VALUES ($1, $2, $3) RETURNING id, org_id, name, token, created_at, revoked_at
`

type CreateApiTokenParams struct {
	OrgID pgtype.UUID
	Name  string
	Token string
}

func (q *Queries) CreateApiToken(ctx context.Context, arg CreateApiTokenParams) (AppApiToken, error) {
	row := q.db.QueryRow(ctx, createApiToken, arg.OrgID, arg.Name, arg.Token)
	var i AppApiToken
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Token,
		&i.CreatedAt,
		&i.RevokedAt,
	)
	return i, err
}

const createCell = `-- name: CreateCell :one
INSERT INTO cell (org_id, cells_group_id, alias, row, level, position) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, org_id, cells_group_id, alias, row, level, position, created_at, deleted_at
`

type CreateCellParams struct {
	OrgID        pgtype.UUID
	CellsGroupID pgtype.UUID
	Alias        string
	Row          int32
	Level        int32
	Position     int32
}

// Cells
func (q *Queries) CreateCell(ctx context.Context, arg CreateCellParams) (Cell, error) {
	row := q.db.QueryRow(ctx, createCell,
		arg.OrgID,
		arg.CellsGroupID,
		arg.Alias,
		arg.Row,
		arg.Level,
		arg.Position,
	)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.CellsGroupID,
		&i.Alias,
		&i.Row,
		&i.Level,
		&i.Position,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createCellsGroup = `-- name: CreateCellsGroup :one
INSERT INTO cells_group (org_id, unit_id, storage_group_id, name, alias) VALUES ($1, $2, $3, $4, $5) RETURNING id, org_id, unit_id, storage_group_id, name, alias, created_at, deleted_at
`

type CreateCellsGroupParams struct {
	OrgID          pgtype.UUID
	UnitID         pgtype.UUID
	StorageGroupID pgtype.UUID
	Name           string
	Alias          string
}

// CellsGroups
func (q *Queries) CreateCellsGroup(ctx context.Context, arg CreateCellsGroupParams) (CellsGroup, error) {
	row := q.db.QueryRow(ctx, createCellsGroup,
		arg.OrgID,
		arg.UnitID,
		arg.StorageGroupID,
		arg.Name,
		arg.Alias,
	)
	var i CellsGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.StorageGroupID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createItem = `-- name: CreateItem :one
INSERT INTO item (org_id, name, description) VALUES ($1, $2, $3) RETURNING id, org_id, name, description, width, depth, height, weight, created_at, deleted_at
`

type CreateItemParams struct {
	OrgID       pgtype.UUID
	Name        string
	Description pgtype.Text
}

// Items
func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem, arg.OrgID, arg.Name, arg.Description)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Width,
		&i.Depth,
		&i.Height,
		&i.Weight,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createItemInstance = `-- name: CreateItemInstance :one
INSERT INTO item_instance (org_id, item_id, variant_id, cell_id, status) VALUES ($1, $2, $3, $4, $5) RETURNING id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at
`

type CreateItemInstanceParams struct {
	OrgID     pgtype.UUID
	ItemID    pgtype.UUID
	VariantID pgtype.UUID
	CellID    pgtype.UUID
	Status    ItemInstanceStatus
}

// Item Instances
func (q *Queries) CreateItemInstance(ctx context.Context, arg CreateItemInstanceParams) (ItemInstance, error) {
	row := q.db.QueryRow(ctx, createItemInstance,
		arg.OrgID,
		arg.ItemID,
		arg.VariantID,
		arg.CellID,
		arg.Status,
	)
	var i ItemInstance
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ItemID,
		&i.VariantID,
		&i.CellID,
		&i.Status,
		&i.AffectedByTaskID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createItemVariant = `-- name: CreateItemVariant :one
INSERT INTO item_variant (org_id, item_id, name, article, ean13) VALUES ($1, $2, $3, $4, $5) RETURNING id, org_id, item_id, name, article, ean13, created_at, deleted_at
`

type CreateItemVariantParams struct {
	OrgID   pgtype.UUID
	ItemID  pgtype.UUID
	Name    string
	Article pgtype.Text
	Ean13   pgtype.Int8
}

// Item Variants
func (q *Queries) CreateItemVariant(ctx context.Context, arg CreateItemVariantParams) (ItemVariant, error) {
	row := q.db.QueryRow(ctx, createItemVariant,
		arg.OrgID,
		arg.ItemID,
		arg.Name,
		arg.Article,
		arg.Ean13,
	)
	var i ItemVariant
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ItemID,
		&i.Name,
		&i.Article,
		&i.Ean13,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createObjectChange = `-- name: CreateObjectChange :one
INSERT INTO app_object_change (org_id, user_id, action, target_object_type, target_object_id, prechange_state, postchange_state) VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, org_id, user_id, action, time, target_object_type, target_object_id, prechange_state, postchange_state
`

type CreateObjectChangeParams struct {
	OrgID            pgtype.UUID
	UserID           pgtype.UUID
	Action           string
	TargetObjectType int32
	TargetObjectID   pgtype.UUID
	PrechangeState   []byte
	PostchangeState  []byte
}

func (q *Queries) CreateObjectChange(ctx context.Context, arg CreateObjectChangeParams) (AppObjectChange, error) {
	row := q.db.QueryRow(ctx, createObjectChange,
		arg.OrgID,
		arg.UserID,
		arg.Action,
		arg.TargetObjectType,
		arg.TargetObjectID,
		arg.PrechangeState,
		arg.PostchangeState,
	)
	var i AppObjectChange
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UserID,
		&i.Action,
		&i.Time,
		&i.TargetObjectType,
		&i.TargetObjectID,
		&i.PrechangeState,
		&i.PostchangeState,
	)
	return i, err
}

const createOrgUnit = `-- name: CreateOrgUnit :one
INSERT INTO org_unit (org_id, name, alias, address) VALUES ($1, $2, $3, $4) RETURNING id, org_id, name, alias, address, created_at, deleted_at
`

type CreateOrgUnitParams struct {
	OrgID   pgtype.UUID
	Name    string
	Alias   string
	Address pgtype.Text
}

// Units
func (q *Queries) CreateOrgUnit(ctx context.Context, arg CreateOrgUnitParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, createOrgUnit,
		arg.OrgID,
		arg.Name,
		arg.Alias,
		arg.Address,
	)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrganization = `-- name: CreateOrganization :one
INSERT INTO org (name, subdomain) VALUES ($1, $2) RETURNING id, name, subdomain, created_at, deleted_at
`

type CreateOrganizationParams struct {
	Name      string
	Subdomain string
}

func (q *Queries) CreateOrganization(ctx context.Context, arg CreateOrganizationParams) (Org, error) {
	row := q.db.QueryRow(ctx, createOrganization, arg.Name, arg.Subdomain)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createStorageGroup = `-- name: CreateStorageGroup :one
INSERT INTO storage_group (org_id, unit_id, parent_id, name, alias) VALUES ($1, $2, $3, $4, $5) RETURNING id, org_id, unit_id, parent_id, name, alias, description, created_at, deleted_at
`

type CreateStorageGroupParams struct {
	OrgID    pgtype.UUID
	UnitID   pgtype.UUID
	ParentID pgtype.UUID
	Name     string
	Alias    string
}

// Storage Groups
func (q *Queries) CreateStorageGroup(ctx context.Context, arg CreateStorageGroupParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, createStorageGroup,
		arg.OrgID,
		arg.UnitID,
		arg.ParentID,
		arg.Name,
		arg.Alias,
	)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTask = `-- name: CreateTask :one
INSERT INTO task (org_id, unit_id, type, name, description, assigned_to_user_id) VALUES ($1, $2, $3, $4, $5, $6) RETURNING id, org_id, unit_id, type, status, name, description, assigned_to_user_id, assigned_at, completed_at, created_at, deleted_at
`

type CreateTaskParams struct {
	OrgID            pgtype.UUID
	UnitID           pgtype.UUID
	Type             TaskType
	Name             string
	Description      pgtype.Text
	AssignedToUserID pgtype.UUID
}

// Tasks
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (Task, error) {
	row := q.db.QueryRow(ctx, createTask,
		arg.OrgID,
		arg.UnitID,
		arg.Type,
		arg.Name,
		arg.Description,
		arg.AssignedToUserID,
	)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.Type,
		&i.Status,
		&i.Name,
		&i.Description,
		&i.AssignedToUserID,
		&i.AssignedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createTaskItem = `-- name: CreateTaskItem :one
INSERT INTO task_item (org_id, task_id, item_instance_id, source_cell_id, destination_cell_id) VALUES ($1, $2, $3, $4, $5) RETURNING org_id, task_id, item_instance_id, status, source_cell_id, destination_cell_id
`

type CreateTaskItemParams struct {
	OrgID             pgtype.UUID
	TaskID            pgtype.UUID
	ItemInstanceID    pgtype.UUID
	SourceCellID      pgtype.UUID
	DestinationCellID pgtype.UUID
}

func (q *Queries) CreateTaskItem(ctx context.Context, arg CreateTaskItemParams) (TaskItem, error) {
	row := q.db.QueryRow(ctx, createTaskItem,
		arg.OrgID,
		arg.TaskID,
		arg.ItemInstanceID,
		arg.SourceCellID,
		arg.DestinationCellID,
	)
	var i TaskItem
	err := row.Scan(
		&i.OrgID,
		&i.TaskID,
		&i.ItemInstanceID,
		&i.Status,
		&i.SourceCellID,
		&i.DestinationCellID,
	)
	return i, err
}

const createTvBoard = `-- name: CreateTvBoard :one
INSERT INTO tv_board (org_id, unit_id, name) VALUES ($1, $2, $3) RETURNING id, org_id, unit_id, name, token, created_at, deleted_at
`

type CreateTvBoardParams struct {
	OrgID  pgtype.UUID
	UnitID pgtype.UUID
	Name   string
}

// TV Boards
func (q *Queries) CreateTvBoard(ctx context.Context, arg CreateTvBoardParams) (TvBoard, error) {
	row := q.db.QueryRow(ctx, createTvBoard, arg.OrgID, arg.UnitID, arg.Name)
	var i TvBoard
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.Name,
		&i.Token,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO app_user (email, first_name, last_name, middle_name, yandex_id) VALUES ($1, $2, $3, $4, $5) RETURNING id, email, first_name, last_name, middle_name, yandex_id, created_at
`

type CreateUserParams struct {
	Email      string
	FirstName  string
	LastName   string
	MiddleName pgtype.Text
	YandexID   pgtype.Text
}

// User
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (AppUser, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.MiddleName,
		arg.YandexID,
	)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.YandexID,
		&i.CreatedAt,
	)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO app_user_session (user_id, token) VALUES ($1, $2) RETURNING id, user_id, token, created_at, expires_at, revoked_at
`

type CreateUserSessionParams struct {
	UserID pgtype.UUID
	Token  string
}

// User Auth
func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (AppUserSession, error) {
	row := q.db.QueryRow(ctx, createUserSession, arg.UserID, arg.Token)
	var i AppUserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const deleteCell = `-- name: DeleteCell :exec
UPDATE cell SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteCellParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteCell(ctx context.Context, arg DeleteCellParams) error {
	_, err := q.db.Exec(ctx, deleteCell, arg.OrgID, arg.ID)
	return err
}

const deleteCellsGroup = `-- name: DeleteCellsGroup :exec
UPDATE cells_group SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteCellsGroupParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteCellsGroup(ctx context.Context, arg DeleteCellsGroupParams) error {
	_, err := q.db.Exec(ctx, deleteCellsGroup, arg.OrgID, arg.ID)
	return err
}

const deleteItem = `-- name: DeleteItem :exec
UPDATE item SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteItemParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) error {
	_, err := q.db.Exec(ctx, deleteItem, arg.OrgID, arg.ID)
	return err
}

const deleteItemInstance = `-- name: DeleteItemInstance :exec
UPDATE item_instance SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteItemInstanceParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteItemInstance(ctx context.Context, arg DeleteItemInstanceParams) error {
	_, err := q.db.Exec(ctx, deleteItemInstance, arg.OrgID, arg.ID)
	return err
}

const deleteItemVariant = `-- name: DeleteItemVariant :exec
UPDATE item_variant SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND item_id = $2 AND id = $3
`

type DeleteItemVariantParams struct {
	OrgID  pgtype.UUID
	ItemID pgtype.UUID
	ID     pgtype.UUID
}

func (q *Queries) DeleteItemVariant(ctx context.Context, arg DeleteItemVariantParams) error {
	_, err := q.db.Exec(ctx, deleteItemVariant, arg.OrgID, arg.ItemID, arg.ID)
	return err
}

const deleteOrgUnit = `-- name: DeleteOrgUnit :exec
UPDATE org_unit SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteOrgUnitParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteOrgUnit(ctx context.Context, arg DeleteOrgUnitParams) error {
	_, err := q.db.Exec(ctx, deleteOrgUnit, arg.OrgID, arg.ID)
	return err
}

const deleteOrganization = `-- name: DeleteOrganization :exec
UPDATE org SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) DeleteOrganization(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrganization, id)
	return err
}

const deleteStorageGroup = `-- name: DeleteStorageGroup :exec
UPDATE storage_group SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteStorageGroupParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteStorageGroup(ctx context.Context, arg DeleteStorageGroupParams) error {
	_, err := q.db.Exec(ctx, deleteStorageGroup, arg.OrgID, arg.ID)
	return err
}

const deleteTvBoard = `-- name: DeleteTvBoard :exec
UPDATE tv_board SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteTvBoardParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteTvBoard(ctx context.Context, arg DeleteTvBoardParams) error {
	_, err := q.db.Exec(ctx, deleteTvBoard, arg.OrgID, arg.ID)
	return err
}

const getApiTokens = `-- name: GetApiTokens :many
SELECT id, org_id, name, token, created_at, revoked_at FROM app_api_token WHERE org_id = $1 AND revoked_at IS NULL
`

// Api Tokens
func (q *Queries) GetApiTokens(ctx context.Context, orgID pgtype.UUID) ([]AppApiToken, error) {
	rows, err := q.db.Query(ctx, getApiTokens, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppApiToken
	for rows.Next() {
		var i AppApiToken
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Token,
			&i.CreatedAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCellById = `-- name: GetCellById :one
SELECT id, org_id, cells_group_id, alias, row, level, position, created_at, deleted_at FROM cell WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetCellByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetCellById(ctx context.Context, arg GetCellByIdParams) (Cell, error) {
	row := q.db.QueryRow(ctx, getCellById, arg.OrgID, arg.ID)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.CellsGroupID,
		&i.Alias,
		&i.Row,
		&i.Level,
		&i.Position,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCellPath = `-- name: GetCellPath :many
WITH RECURSIVE path AS (
  SELECT
    cg.id,
    'cells_group'      AS type,
    cg.alias,
    cg.name,
    cg.storage_group_id AS parent_group_id,
    NULL::UUID         AS unit_id,
    1                  AS lvl
  FROM cell c
  JOIN cells_group cg
    ON c.cells_group_id = cg.id
   AND c.org_id         = cg.org_id
  WHERE c.org_id = $1
    AND c.id     = $2

  UNION ALL

  SELECT
    sg.id,
    'storage_group'    AS type,
    sg.alias,
    sg.name,
    sg.parent_id       AS parent_group_id,
    sg.unit_id,
    p.lvl + 1          AS lvl
  FROM path p
  JOIN storage_group sg
    ON sg.id     = p.parent_group_id
   AND sg.org_id = $1
)

SELECT id, type, alias, name
FROM (
  SELECT id, type, alias, name, lvl
  FROM path

  UNION ALL

  SELECT
    ou.id,
    'unit'            AS type,
    ou.alias,
    ou.name,
    MAX(p.lvl) + 1    AS lvl
  FROM path p
  JOIN org_unit ou
    ON ou.id     = p.unit_id
   AND ou.org_id = $1
  GROUP BY ou.id, ou.alias, ou.name
) t
ORDER BY lvl
`

type GetCellPathParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

type GetCellPathRow struct {
	ID    pgtype.UUID
	Type  string
	Alias string
	Name  string
}

func (q *Queries) GetCellPath(ctx context.Context, arg GetCellPathParams) ([]GetCellPathRow, error) {
	rows, err := q.db.Query(ctx, getCellPath, arg.OrgID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCellPathRow
	for rows.Next() {
		var i GetCellPathRow
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Alias,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCells = `-- name: GetCells :many
SELECT id, org_id, cells_group_id, alias, row, level, position, created_at, deleted_at FROM cell WHERE org_id = $1 AND cells_group_id = $2 AND deleted_at IS NULL
`

type GetCellsParams struct {
	OrgID        pgtype.UUID
	CellsGroupID pgtype.UUID
}

func (q *Queries) GetCells(ctx context.Context, arg GetCellsParams) ([]Cell, error) {
	rows, err := q.db.Query(ctx, getCells, arg.OrgID, arg.CellsGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cell
	for rows.Next() {
		var i Cell
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.CellsGroupID,
			&i.Alias,
			&i.Row,
			&i.Level,
			&i.Position,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCellsGroupById = `-- name: GetCellsGroupById :one
SELECT id, org_id, unit_id, storage_group_id, name, alias, created_at, deleted_at FROM cells_group WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetCellsGroupByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetCellsGroupById(ctx context.Context, arg GetCellsGroupByIdParams) (CellsGroup, error) {
	row := q.db.QueryRow(ctx, getCellsGroupById, arg.OrgID, arg.ID)
	var i CellsGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.StorageGroupID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCellsGroups = `-- name: GetCellsGroups :many
SELECT id, org_id, unit_id, storage_group_id, name, alias, created_at, deleted_at FROM cells_group WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetCellsGroups(ctx context.Context, orgID pgtype.UUID) ([]CellsGroup, error) {
	rows, err := q.db.Query(ctx, getCellsGroups, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CellsGroup
	for rows.Next() {
		var i CellsGroup
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UnitID,
			&i.StorageGroupID,
			&i.Name,
			&i.Alias,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployee = `-- name: GetEmployee :one
SELECT app_user.id, app_user.email, app_user.first_name, app_user.last_name, app_user.middle_name, app_user.yandex_id, app_user.created_at, app_role.id, app_role.name, app_role.display_name, app_role.description FROM app_user
JOIN app_role_binding ON app_user.id = app_role_binding.user_id
JOIN app_role ON app_role_binding.role_id = app_role.id
WHERE app_role_binding.org_id = $1 AND app_role_binding.user_id = $2
`

type GetEmployeeParams struct {
	OrgID  pgtype.UUID
	UserID pgtype.UUID
}

type GetEmployeeRow struct {
	AppUser AppUser
	AppRole AppRole
}

func (q *Queries) GetEmployee(ctx context.Context, arg GetEmployeeParams) (GetEmployeeRow, error) {
	row := q.db.QueryRow(ctx, getEmployee, arg.OrgID, arg.UserID)
	var i GetEmployeeRow
	err := row.Scan(
		&i.AppUser.ID,
		&i.AppUser.Email,
		&i.AppUser.FirstName,
		&i.AppUser.LastName,
		&i.AppUser.MiddleName,
		&i.AppUser.YandexID,
		&i.AppUser.CreatedAt,
		&i.AppRole.ID,
		&i.AppRole.Name,
		&i.AppRole.DisplayName,
		&i.AppRole.Description,
	)
	return i, err
}

const getEmployeeByUserId = `-- name: GetEmployeeByUserId :one
SELECT 
    u.id as user_id,
    u.email,
    u.first_name,
    u.last_name,
    u.middle_name,
    rb.role_id
FROM app_user u
JOIN app_role_binding rb ON rb.user_id = u.id
WHERE rb.org_id = $1 AND rb.user_id = $2
`

type GetEmployeeByUserIdParams struct {
	OrgID  pgtype.UUID
	UserID pgtype.UUID
}

type GetEmployeeByUserIdRow struct {
	UserID     pgtype.UUID
	Email      string
	FirstName  string
	LastName   string
	MiddleName pgtype.Text
	RoleID     int32
}

func (q *Queries) GetEmployeeByUserId(ctx context.Context, arg GetEmployeeByUserIdParams) (GetEmployeeByUserIdRow, error) {
	row := q.db.QueryRow(ctx, getEmployeeByUserId, arg.OrgID, arg.UserID)
	var i GetEmployeeByUserIdRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.RoleID,
	)
	return i, err
}

const getEmployees = `-- name: GetEmployees :many
SELECT app_user.id, app_user.email, app_user.first_name, app_user.last_name, app_user.middle_name, app_user.yandex_id, app_user.created_at, app_role.id, app_role.name, app_role.display_name, app_role.description FROM app_user
JOIN app_role_binding ON app_user.id = app_role_binding.user_id
JOIN app_role ON app_role_binding.role_id = app_role.id
WHERE app_role_binding.org_id = $1
`

type GetEmployeesRow struct {
	AppUser AppUser
	AppRole AppRole
}

func (q *Queries) GetEmployees(ctx context.Context, orgID pgtype.UUID) ([]GetEmployeesRow, error) {
	rows, err := q.db.Query(ctx, getEmployees, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesRow
	for rows.Next() {
		var i GetEmployeesRow
		if err := rows.Scan(
			&i.AppUser.ID,
			&i.AppUser.Email,
			&i.AppUser.FirstName,
			&i.AppUser.LastName,
			&i.AppUser.MiddleName,
			&i.AppUser.YandexID,
			&i.AppUser.CreatedAt,
			&i.AppRole.ID,
			&i.AppRole.Name,
			&i.AppRole.DisplayName,
			&i.AppRole.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemById = `-- name: GetItemById :one
SELECT id, org_id, name, description, width, depth, height, weight, created_at, deleted_at FROM item WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetItemByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetItemById(ctx context.Context, arg GetItemByIdParams) (Item, error) {
	row := q.db.QueryRow(ctx, getItemById, arg.OrgID, arg.ID)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Width,
		&i.Depth,
		&i.Height,
		&i.Weight,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getItemInstance = `-- name: GetItemInstance :one
SELECT id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at FROM item_instance WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetItemInstanceParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetItemInstance(ctx context.Context, arg GetItemInstanceParams) (ItemInstance, error) {
	row := q.db.QueryRow(ctx, getItemInstance, arg.OrgID, arg.ID)
	var i ItemInstance
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ItemID,
		&i.VariantID,
		&i.CellID,
		&i.Status,
		&i.AffectedByTaskID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getItemInstancesAll = `-- name: GetItemInstancesAll :many
SELECT id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at FROM item_instance WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetItemInstancesAll(ctx context.Context, orgID pgtype.UUID) ([]ItemInstance, error) {
	rows, err := q.db.Query(ctx, getItemInstancesAll, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemInstance
	for rows.Next() {
		var i ItemInstance
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ItemID,
			&i.VariantID,
			&i.CellID,
			&i.Status,
			&i.AffectedByTaskID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemInstancesForCell = `-- name: GetItemInstancesForCell :many
SELECT id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at FROM item_instance WHERE org_id = $1 AND cell_id = $2 AND deleted_at IS NULL
`

type GetItemInstancesForCellParams struct {
	OrgID  pgtype.UUID
	CellID pgtype.UUID
}

func (q *Queries) GetItemInstancesForCell(ctx context.Context, arg GetItemInstancesForCellParams) ([]ItemInstance, error) {
	rows, err := q.db.Query(ctx, getItemInstancesForCell, arg.OrgID, arg.CellID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemInstance
	for rows.Next() {
		var i ItemInstance
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ItemID,
			&i.VariantID,
			&i.CellID,
			&i.Status,
			&i.AffectedByTaskID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemInstancesForCellsGroup = `-- name: GetItemInstancesForCellsGroup :many
SELECT id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at FROM item_instance WHERE item_instance.org_id = $1 AND cell_id IN (SELECT id FROM cell WHERE cells_group_id = $2 AND deleted_at IS NULL) AND deleted_at IS NULL
`

type GetItemInstancesForCellsGroupParams struct {
	OrgID        pgtype.UUID
	CellsGroupID pgtype.UUID
}

func (q *Queries) GetItemInstancesForCellsGroup(ctx context.Context, arg GetItemInstancesForCellsGroupParams) ([]ItemInstance, error) {
	rows, err := q.db.Query(ctx, getItemInstancesForCellsGroup, arg.OrgID, arg.CellsGroupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemInstance
	for rows.Next() {
		var i ItemInstance
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ItemID,
			&i.VariantID,
			&i.CellID,
			&i.Status,
			&i.AffectedByTaskID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemInstancesForItem = `-- name: GetItemInstancesForItem :many
SELECT id, org_id, item_id, variant_id, cell_id, status, affected_by_task_id, created_at, deleted_at FROM item_instance WHERE org_id = $1 AND item_id = $2 AND deleted_at IS NULL
`

type GetItemInstancesForItemParams struct {
	OrgID  pgtype.UUID
	ItemID pgtype.UUID
}

func (q *Queries) GetItemInstancesForItem(ctx context.Context, arg GetItemInstancesForItemParams) ([]ItemInstance, error) {
	rows, err := q.db.Query(ctx, getItemInstancesForItem, arg.OrgID, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemInstance
	for rows.Next() {
		var i ItemInstance
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ItemID,
			&i.VariantID,
			&i.CellID,
			&i.Status,
			&i.AffectedByTaskID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemVariantById = `-- name: GetItemVariantById :one
SELECT id, org_id, item_id, name, article, ean13, created_at, deleted_at FROM item_variant WHERE org_id = $1 AND item_id = $2 AND id = $3 AND deleted_at IS NULL
`

type GetItemVariantByIdParams struct {
	OrgID  pgtype.UUID
	ItemID pgtype.UUID
	ID     pgtype.UUID
}

func (q *Queries) GetItemVariantById(ctx context.Context, arg GetItemVariantByIdParams) (ItemVariant, error) {
	row := q.db.QueryRow(ctx, getItemVariantById, arg.OrgID, arg.ItemID, arg.ID)
	var i ItemVariant
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ItemID,
		&i.Name,
		&i.Article,
		&i.Ean13,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getItemVariants = `-- name: GetItemVariants :many
SELECT id, org_id, item_id, name, article, ean13, created_at, deleted_at FROM item_variant WHERE org_id = $1 AND item_id = $2 AND deleted_at IS NULL
`

type GetItemVariantsParams struct {
	OrgID  pgtype.UUID
	ItemID pgtype.UUID
}

func (q *Queries) GetItemVariants(ctx context.Context, arg GetItemVariantsParams) ([]ItemVariant, error) {
	rows, err := q.db.Query(ctx, getItemVariants, arg.OrgID, arg.ItemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemVariant
	for rows.Next() {
		var i ItemVariant
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.ItemID,
			&i.Name,
			&i.Article,
			&i.Ean13,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItems = `-- name: GetItems :many
SELECT id, org_id, name, description, width, depth, height, weight, created_at, deleted_at FROM item WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetItems(ctx context.Context, orgID pgtype.UUID) ([]Item, error) {
	rows, err := q.db.Query(ctx, getItems, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.Width,
			&i.Depth,
			&i.Height,
			&i.Weight,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectChanges = `-- name: GetObjectChanges :many
SELECT id, org_id, user_id, action, time, target_object_type, target_object_id, prechange_state, postchange_state FROM app_object_change WHERE org_id = $1 AND target_object_type = $2 AND target_object_id = $3
`

type GetObjectChangesParams struct {
	OrgID            pgtype.UUID
	TargetObjectType int32
	TargetObjectID   pgtype.UUID
}

func (q *Queries) GetObjectChanges(ctx context.Context, arg GetObjectChangesParams) ([]AppObjectChange, error) {
	rows, err := q.db.Query(ctx, getObjectChanges, arg.OrgID, arg.TargetObjectType, arg.TargetObjectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppObjectChange
	for rows.Next() {
		var i AppObjectChange
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UserID,
			&i.Action,
			&i.Time,
			&i.TargetObjectType,
			&i.TargetObjectID,
			&i.PrechangeState,
			&i.PostchangeState,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectTypeById = `-- name: GetObjectTypeById :one
SELECT id, object_group, object_name FROM object_type WHERE id = $1
`

// Audit Log
func (q *Queries) GetObjectTypeById(ctx context.Context, id int32) (ObjectType, error) {
	row := q.db.QueryRow(ctx, getObjectTypeById, id)
	var i ObjectType
	err := row.Scan(&i.ID, &i.ObjectGroup, &i.ObjectName)
	return i, err
}

const getOrgIdByApiToken = `-- name: GetOrgIdByApiToken :one
SELECT org_id FROM app_api_token WHERE token = $1 AND revoked_at IS NULL
`

func (q *Queries) GetOrgIdByApiToken(ctx context.Context, token string) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getOrgIdByApiToken, token)
	var org_id pgtype.UUID
	err := row.Scan(&org_id)
	return org_id, err
}

const getOrgUnitById = `-- name: GetOrgUnitById :one
SELECT id, org_id, name, alias, address, created_at, deleted_at FROM org_unit WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetOrgUnitByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetOrgUnitById(ctx context.Context, arg GetOrgUnitByIdParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, getOrgUnitById, arg.OrgID, arg.ID)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgUnits = `-- name: GetOrgUnits :many
SELECT id, org_id, name, alias, address, created_at, deleted_at FROM org_unit WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrgUnits(ctx context.Context, orgID pgtype.UUID) ([]OrgUnit, error) {
	rows, err := q.db.Query(ctx, getOrgUnits, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgUnit
	for rows.Next() {
		var i OrgUnit
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Alias,
			&i.Address,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganization = `-- name: GetOrganization :one
SELECT id, name, subdomain, created_at, deleted_at FROM org WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrganization(ctx context.Context, id pgtype.UUID) (Org, error) {
	row := q.db.QueryRow(ctx, getOrganization, id)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRoleById = `-- name: GetRoleById :one
SELECT id, name, display_name, description FROM app_role WHERE id = $1
`

func (q *Queries) GetRoleById(ctx context.Context, id int32) (AppRole, error) {
	row := q.db.QueryRow(ctx, getRoleById, id)
	var i AppRole
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DisplayName,
		&i.Description,
	)
	return i, err
}

const getRoles = `-- name: GetRoles :many
SELECT id, name, display_name, description FROM app_role
`

func (q *Queries) GetRoles(ctx context.Context) ([]AppRole, error) {
	rows, err := q.db.Query(ctx, getRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AppRole
	for rows.Next() {
		var i AppRole
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DisplayName,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionBySecret = `-- name: GetSessionBySecret :one
SELECT id, user_id, token, created_at, expires_at, revoked_at FROM app_user_session WHERE token = $1 LIMIT 1
`

func (q *Queries) GetSessionBySecret(ctx context.Context, token string) (AppUserSession, error) {
	row := q.db.QueryRow(ctx, getSessionBySecret, token)
	var i AppUserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const getStorageGroupById = `-- name: GetStorageGroupById :one
SELECT id, org_id, unit_id, parent_id, name, alias, description, created_at, deleted_at FROM storage_group WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetStorageGroupByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetStorageGroupById(ctx context.Context, arg GetStorageGroupByIdParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, getStorageGroupById, arg.OrgID, arg.ID)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStorageGroups = `-- name: GetStorageGroups :many
SELECT id, org_id, unit_id, parent_id, name, alias, description, created_at, deleted_at FROM storage_group WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetStorageGroups(ctx context.Context, orgID pgtype.UUID) ([]StorageGroup, error) {
	rows, err := q.db.Query(ctx, getStorageGroups, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageGroup
	for rows.Next() {
		var i StorageGroup
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UnitID,
			&i.ParentID,
			&i.Name,
			&i.Alias,
			&i.Description,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskById = `-- name: GetTaskById :one
SELECT id, org_id, unit_id, type, status, name, description, assigned_to_user_id, assigned_at, completed_at, created_at, deleted_at FROM task WHERE org_id = $1 AND id = $2
`

type GetTaskByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetTaskById(ctx context.Context, arg GetTaskByIdParams) (Task, error) {
	row := q.db.QueryRow(ctx, getTaskById, arg.OrgID, arg.ID)
	var i Task
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.Type,
		&i.Status,
		&i.Name,
		&i.Description,
		&i.AssignedToUserID,
		&i.AssignedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTaskItems = `-- name: GetTaskItems :many
SELECT org_id, task_id, item_instance_id, status, source_cell_id, destination_cell_id FROM task_item WHERE org_id = $1 AND task_id = $2
`

type GetTaskItemsParams struct {
	OrgID  pgtype.UUID
	TaskID pgtype.UUID
}

func (q *Queries) GetTaskItems(ctx context.Context, arg GetTaskItemsParams) ([]TaskItem, error) {
	rows, err := q.db.Query(ctx, getTaskItems, arg.OrgID, arg.TaskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskItem
	for rows.Next() {
		var i TaskItem
		if err := rows.Scan(
			&i.OrgID,
			&i.TaskID,
			&i.ItemInstanceID,
			&i.Status,
			&i.SourceCellID,
			&i.DestinationCellID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasks = `-- name: GetTasks :many
SELECT id, org_id, unit_id, type, status, name, description, assigned_to_user_id, assigned_at, completed_at, created_at, deleted_at FROM task WHERE org_id = $1
`

func (q *Queries) GetTasks(ctx context.Context, orgID pgtype.UUID) ([]Task, error) {
	rows, err := q.db.Query(ctx, getTasks, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UnitID,
			&i.Type,
			&i.Status,
			&i.Name,
			&i.Description,
			&i.AssignedToUserID,
			&i.AssignedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTvBoardById = `-- name: GetTvBoardById :one
SELECT id, org_id, unit_id, name, token, created_at, deleted_at FROM tv_board WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetTvBoardByIdParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetTvBoardById(ctx context.Context, arg GetTvBoardByIdParams) (TvBoard, error) {
	row := q.db.QueryRow(ctx, getTvBoardById, arg.OrgID, arg.ID)
	var i TvBoard
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.Name,
		&i.Token,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTvBoardByToken = `-- name: GetTvBoardByToken :one
SELECT id, org_id, unit_id, name, token, created_at, deleted_at FROM tv_board WHERE token = $1 AND deleted_at IS NULL LIMIT 1
`

func (q *Queries) GetTvBoardByToken(ctx context.Context, token string) (TvBoard, error) {
	row := q.db.QueryRow(ctx, getTvBoardByToken, token)
	var i TvBoard
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.Name,
		&i.Token,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getTvBoards = `-- name: GetTvBoards :many
SELECT id, org_id, unit_id, name, token, created_at, deleted_at FROM tv_board WHERE org_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetTvBoards(ctx context.Context, orgID pgtype.UUID) ([]TvBoard, error) {
	rows, err := q.db.Query(ctx, getTvBoards, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TvBoard
	for rows.Next() {
		var i TvBoard
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UnitID,
			&i.Name,
			&i.Token,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, first_name, last_name, middle_name, yandex_id, created_at FROM app_user WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (AppUser, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.YandexID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, first_name, last_name, middle_name, yandex_id, created_at FROM app_user WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id pgtype.UUID) (AppUser, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i AppUser
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.MiddleName,
		&i.YandexID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserOrgs = `-- name: GetUserOrgs :many
SELECT id, name, subdomain, created_at, deleted_at FROM org WHERE id IN (SELECT org_id FROM app_role_binding WHERE user_id = $1) AND deleted_at IS NULL
`

// Organizations
func (q *Queries) GetUserOrgs(ctx context.Context, userID pgtype.UUID) ([]Org, error) {
	rows, err := q.db.Query(ctx, getUserOrgs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Org
	for rows.Next() {
		var i Org
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Subdomain,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoleInOrg = `-- name: GetUserRoleInOrg :one
SELECT app_role.id, app_role.name, app_role.display_name, app_role.description FROM app_role 
JOIN app_role_binding ON app_role.id = app_role_binding.role_id
WHERE app_role_binding.user_id = $2 AND app_role_binding.org_id = $1
`

type GetUserRoleInOrgParams struct {
	OrgID  pgtype.UUID
	UserID pgtype.UUID
}

type GetUserRoleInOrgRow struct {
	AppRole AppRole
}

func (q *Queries) GetUserRoleInOrg(ctx context.Context, arg GetUserRoleInOrgParams) (GetUserRoleInOrgRow, error) {
	row := q.db.QueryRow(ctx, getUserRoleInOrg, arg.OrgID, arg.UserID)
	var i GetUserRoleInOrgRow
	err := row.Scan(
		&i.AppRole.ID,
		&i.AppRole.Name,
		&i.AppRole.DisplayName,
		&i.AppRole.Description,
	)
	return i, err
}

const invalidateSession = `-- name: InvalidateSession :exec
UPDATE app_user_session SET revoked_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) InvalidateSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, invalidateSession, id)
	return err
}

const revokeApiToken = `-- name: RevokeApiToken :exec
UPDATE app_api_token SET revoked_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type RevokeApiTokenParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) RevokeApiToken(ctx context.Context, arg RevokeApiTokenParams) error {
	_, err := q.db.Exec(ctx, revokeApiToken, arg.OrgID, arg.ID)
	return err
}

const setItemInstanceCell = `-- name: SetItemInstanceCell :exec
UPDATE item_instance SET cell_id = $3 WHERE org_id = $1 AND id = $2
`

type SetItemInstanceCellParams struct {
	OrgID  pgtype.UUID
	ID     pgtype.UUID
	CellID pgtype.UUID
}

func (q *Queries) SetItemInstanceCell(ctx context.Context, arg SetItemInstanceCellParams) error {
	_, err := q.db.Exec(ctx, setItemInstanceCell, arg.OrgID, arg.ID, arg.CellID)
	return err
}

const setItemInstanceTaskStatus = `-- name: SetItemInstanceTaskStatus :exec
UPDATE item_instance SET status = $3, affected_by_task_id = $4 WHERE org_id = $1 AND id = $2
`

type SetItemInstanceTaskStatusParams struct {
	OrgID            pgtype.UUID
	ID               pgtype.UUID
	Status           ItemInstanceStatus
	AffectedByTaskID pgtype.UUID
}

func (q *Queries) SetItemInstanceTaskStatus(ctx context.Context, arg SetItemInstanceTaskStatusParams) error {
	_, err := q.db.Exec(ctx, setItemInstanceTaskStatus,
		arg.OrgID,
		arg.ID,
		arg.Status,
		arg.AffectedByTaskID,
	)
	return err
}

const setTaskItemStatus = `-- name: SetTaskItemStatus :exec
UPDATE task_item SET status = $3 WHERE org_id = $1 AND item_instance_id = $2
`

type SetTaskItemStatusParams struct {
	OrgID          pgtype.UUID
	ItemInstanceID pgtype.UUID
	Status         TaskItemStatus
}

func (q *Queries) SetTaskItemStatus(ctx context.Context, arg SetTaskItemStatusParams) error {
	_, err := q.db.Exec(ctx, setTaskItemStatus, arg.OrgID, arg.ItemInstanceID, arg.Status)
	return err
}

const unassignRoleFromUser = `-- name: UnassignRoleFromUser :exec
DELETE FROM app_role_binding WHERE org_id = $1 AND user_id = $2
`

type UnassignRoleFromUserParams struct {
	OrgID  pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) UnassignRoleFromUser(ctx context.Context, arg UnassignRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, unassignRoleFromUser, arg.OrgID, arg.UserID)
	return err
}

const updateCell = `-- name: UpdateCell :one
UPDATE cell SET alias = $4, row = $5, level = $6, position = $7 WHERE org_id = $1 AND cells_group_id = $2 AND id = $3 AND deleted_at IS NULL RETURNING id, org_id, cells_group_id, alias, row, level, position, created_at, deleted_at
`

type UpdateCellParams struct {
	OrgID        pgtype.UUID
	CellsGroupID pgtype.UUID
	ID           pgtype.UUID
	Alias        string
	Row          int32
	Level        int32
	Position     int32
}

func (q *Queries) UpdateCell(ctx context.Context, arg UpdateCellParams) (Cell, error) {
	row := q.db.QueryRow(ctx, updateCell,
		arg.OrgID,
		arg.CellsGroupID,
		arg.ID,
		arg.Alias,
		arg.Row,
		arg.Level,
		arg.Position,
	)
	var i Cell
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.CellsGroupID,
		&i.Alias,
		&i.Row,
		&i.Level,
		&i.Position,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCellsGroup = `-- name: UpdateCellsGroup :one
UPDATE cells_group SET name = $3, alias = $4, unit_id = $5 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, unit_id, storage_group_id, name, alias, created_at, deleted_at
`

type UpdateCellsGroupParams struct {
	OrgID  pgtype.UUID
	ID     pgtype.UUID
	Name   string
	Alias  string
	UnitID pgtype.UUID
}

func (q *Queries) UpdateCellsGroup(ctx context.Context, arg UpdateCellsGroupParams) (CellsGroup, error) {
	row := q.db.QueryRow(ctx, updateCellsGroup,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Alias,
		arg.UnitID,
	)
	var i CellsGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.StorageGroupID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateItem = `-- name: UpdateItem :one
UPDATE item SET name = $3, description = $4 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, name, description, width, depth, height, weight, created_at, deleted_at
`

type UpdateItemParams struct {
	OrgID       pgtype.UUID
	ID          pgtype.UUID
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, updateItem,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Description,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.Width,
		&i.Depth,
		&i.Height,
		&i.Weight,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateItemVariant = `-- name: UpdateItemVariant :one
UPDATE item_variant SET name = $4, article = $5, ean13 = $6 WHERE org_id = $1 AND item_id = $2 AND id = $3 AND deleted_at IS NULL RETURNING id, org_id, item_id, name, article, ean13, created_at, deleted_at
`

type UpdateItemVariantParams struct {
	OrgID   pgtype.UUID
	ItemID  pgtype.UUID
	ID      pgtype.UUID
	Name    string
	Article pgtype.Text
	Ean13   pgtype.Int8
}

func (q *Queries) UpdateItemVariant(ctx context.Context, arg UpdateItemVariantParams) (ItemVariant, error) {
	row := q.db.QueryRow(ctx, updateItemVariant,
		arg.OrgID,
		arg.ItemID,
		arg.ID,
		arg.Name,
		arg.Article,
		arg.Ean13,
	)
	var i ItemVariant
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.ItemID,
		&i.Name,
		&i.Article,
		&i.Ean13,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateOrgUnit = `-- name: UpdateOrgUnit :one
UPDATE org_unit SET name = $3, alias = $4, address = $5 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, name, alias, address, created_at, deleted_at
`

type UpdateOrgUnitParams struct {
	OrgID   pgtype.UUID
	ID      pgtype.UUID
	Name    string
	Alias   string
	Address pgtype.Text
}

func (q *Queries) UpdateOrgUnit(ctx context.Context, arg UpdateOrgUnitParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, updateOrgUnit,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Alias,
		arg.Address,
	)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateOrganization = `-- name: UpdateOrganization :one
UPDATE org SET name = $2 WHERE id = $1 RETURNING id, name, subdomain, created_at, deleted_at
`

type UpdateOrganizationParams struct {
	ID   pgtype.UUID
	Name string
}

func (q *Queries) UpdateOrganization(ctx context.Context, arg UpdateOrganizationParams) (Org, error) {
	row := q.db.QueryRow(ctx, updateOrganization, arg.ID, arg.Name)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateStorageGroup = `-- name: UpdateStorageGroup :one
UPDATE storage_group SET name = $3, alias = $4, unit_id = $5 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, unit_id, parent_id, name, alias, description, created_at, deleted_at
`

type UpdateStorageGroupParams struct {
	OrgID  pgtype.UUID
	ID     pgtype.UUID
	Name   string
	Alias  string
	UnitID pgtype.UUID
}

func (q *Queries) UpdateStorageGroup(ctx context.Context, arg UpdateStorageGroupParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, updateStorageGroup,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Alias,
		arg.UnitID,
	)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}
