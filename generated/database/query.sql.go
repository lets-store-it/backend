// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: query.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createItem = `-- name: CreateItem :one
INSERT INTO item (org_id, name, description) VALUES ($1, $2, $3) RETURNING id, org_id, name, description, created_at, deleted_at
`

type CreateItemParams struct {
	OrgID       pgtype.UUID
	Name        string
	Description pgtype.Text
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, createItem, arg.OrgID, arg.Name, arg.Description)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createItemVariant = `-- name: CreateItemVariant :one
INSERT INTO item_variant (item_id, name, article, ean13) VALUES ($1, $2, $3, $4) RETURNING id, item_id, name, article, ean13, created_at, deleted_at
`

type CreateItemVariantParams struct {
	ItemID  pgtype.UUID
	Name    string
	Article pgtype.Text
	Ean13   pgtype.Int4
}

func (q *Queries) CreateItemVariant(ctx context.Context, arg CreateItemVariantParams) (ItemVariant, error) {
	row := q.db.QueryRow(ctx, createItemVariant,
		arg.ItemID,
		arg.Name,
		arg.Article,
		arg.Ean13,
	)
	var i ItemVariant
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Name,
		&i.Article,
		&i.Ean13,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrg = `-- name: CreateOrg :one
INSERT INTO org (name, subdomain) VALUES ($1, $2) RETURNING id, name, subdomain, created_at, deleted_at
`

type CreateOrgParams struct {
	Name      string
	Subdomain string
}

func (q *Queries) CreateOrg(ctx context.Context, arg CreateOrgParams) (Org, error) {
	row := q.db.QueryRow(ctx, createOrg, arg.Name, arg.Subdomain)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrgUnit = `-- name: CreateOrgUnit :one
INSERT INTO org_unit (org_id, name, alias, address) VALUES ($1, $2, $3, $4) RETURNING id, org_id, name, alias, address, created_at, deleted_at
`

type CreateOrgUnitParams struct {
	OrgID   pgtype.UUID
	Name    string
	Alias   string
	Address pgtype.Text
}

func (q *Queries) CreateOrgUnit(ctx context.Context, arg CreateOrgUnitParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, createOrgUnit,
		arg.OrgID,
		arg.Name,
		arg.Alias,
		arg.Address,
	)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createStorageGroup = `-- name: CreateStorageGroup :one
INSERT INTO storage_group (org_id, unit_id, parent_id, name, alias) VALUES ($1, $2, $3, $4, $5) RETURNING id, org_id, unit_id, parent_id, name, alias, created_at, deleted_at
`

type CreateStorageGroupParams struct {
	OrgID    pgtype.UUID
	UnitID   pgtype.UUID
	ParentID pgtype.UUID
	Name     string
	Alias    string
}

func (q *Queries) CreateStorageGroup(ctx context.Context, arg CreateStorageGroupParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, createStorageGroup,
		arg.OrgID,
		arg.UnitID,
		arg.ParentID,
		arg.Name,
		arg.Alias,
	)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteItem = `-- name: DeleteItem :exec
UPDATE item SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteItemParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteItem(ctx context.Context, arg DeleteItemParams) error {
	_, err := q.db.Exec(ctx, deleteItem, arg.OrgID, arg.ID)
	return err
}

const deleteItemVariant = `-- name: DeleteItemVariant :exec
UPDATE item_variant SET deleted_at = CURRENT_TIMESTAMP WHERE item_id = $1 AND id = $2
`

type DeleteItemVariantParams struct {
	ItemID pgtype.UUID
	ID     pgtype.UUID
}

func (q *Queries) DeleteItemVariant(ctx context.Context, arg DeleteItemVariantParams) error {
	_, err := q.db.Exec(ctx, deleteItemVariant, arg.ItemID, arg.ID)
	return err
}

const deleteOrg = `-- name: DeleteOrg :exec
UPDATE org SET deleted_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) DeleteOrg(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrg, id)
	return err
}

const deleteOrgUnit = `-- name: DeleteOrgUnit :exec
UPDATE org_unit SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteOrgUnitParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteOrgUnit(ctx context.Context, arg DeleteOrgUnitParams) error {
	_, err := q.db.Exec(ctx, deleteOrgUnit, arg.OrgID, arg.ID)
	return err
}

const deleteStorageGroup = `-- name: DeleteStorageGroup :exec
UPDATE storage_group SET deleted_at = CURRENT_TIMESTAMP WHERE org_id = $1 AND id = $2
`

type DeleteStorageGroupParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) DeleteStorageGroup(ctx context.Context, arg DeleteStorageGroupParams) error {
	_, err := q.db.Exec(ctx, deleteStorageGroup, arg.OrgID, arg.ID)
	return err
}

const getActiveItems = `-- name: GetActiveItems :many
SELECT id, org_id, name, description, created_at, deleted_at FROM item WHERE org_id = $1 AND deleted_at IS NULL
`

// Items
func (q *Queries) GetActiveItems(ctx context.Context, orgID pgtype.UUID) ([]Item, error) {
	rows, err := q.db.Query(ctx, getActiveItems, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Item
	for rows.Next() {
		var i Item
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveOrgUnits = `-- name: GetActiveOrgUnits :many
SELECT id, org_id, name, alias, address, created_at, deleted_at FROM org_unit WHERE org_id = $1 AND deleted_at IS NULL
`

// Units
func (q *Queries) GetActiveOrgUnits(ctx context.Context, orgID pgtype.UUID) ([]OrgUnit, error) {
	rows, err := q.db.Query(ctx, getActiveOrgUnits, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []OrgUnit
	for rows.Next() {
		var i OrgUnit
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.Name,
			&i.Alias,
			&i.Address,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveOrgs = `-- name: GetActiveOrgs :many
SELECT id, name, subdomain, created_at, deleted_at FROM org WHERE deleted_at IS NULL
`

func (q *Queries) GetActiveOrgs(ctx context.Context) ([]Org, error) {
	rows, err := q.db.Query(ctx, getActiveOrgs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Org
	for rows.Next() {
		var i Org
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Subdomain,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveStorageGroups = `-- name: GetActiveStorageGroups :many
SELECT id, org_id, unit_id, parent_id, name, alias, created_at, deleted_at FROM storage_group WHERE org_id = $1 AND deleted_at IS NULL
`

// Storage spaces
func (q *Queries) GetActiveStorageGroups(ctx context.Context, orgID pgtype.UUID) ([]StorageGroup, error) {
	rows, err := q.db.Query(ctx, getActiveStorageGroups, orgID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StorageGroup
	for rows.Next() {
		var i StorageGroup
		if err := rows.Scan(
			&i.ID,
			&i.OrgID,
			&i.UnitID,
			&i.ParentID,
			&i.Name,
			&i.Alias,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItem = `-- name: GetItem :one
SELECT id, org_id, name, description, created_at, deleted_at FROM item WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetItemParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetItem(ctx context.Context, arg GetItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, getItem, arg.OrgID, arg.ID)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getItemVariants = `-- name: GetItemVariants :many

SELECT id, item_id, name, article, ean13, created_at, deleted_at FROM item_variant WHERE item_id = $1 AND deleted_at IS NULL
`

// -- name: GetActiveItemWithVariants :many
// SELECT * FROM item
// JOIN item_variant ON item.id = item_variant.item_id
// WHERE item.org_id = $1 AND item.deleted_at IS NULL
// GROUP BY item.id;
func (q *Queries) GetItemVariants(ctx context.Context, itemID pgtype.UUID) ([]ItemVariant, error) {
	rows, err := q.db.Query(ctx, getItemVariants, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemVariant
	for rows.Next() {
		var i ItemVariant
		if err := rows.Scan(
			&i.ID,
			&i.ItemID,
			&i.Name,
			&i.Article,
			&i.Ean13,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrg = `-- name: GetOrg :one
SELECT id, name, subdomain, created_at, deleted_at FROM org WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetOrg(ctx context.Context, id pgtype.UUID) (Org, error) {
	row := q.db.QueryRow(ctx, getOrg, id)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrgUnit = `-- name: GetOrgUnit :one
SELECT id, org_id, name, alias, address, created_at, deleted_at FROM org_unit WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetOrgUnitParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetOrgUnit(ctx context.Context, arg GetOrgUnitParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, getOrgUnit, arg.OrgID, arg.ID)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getStorageGroup = `-- name: GetStorageGroup :one
SELECT id, org_id, unit_id, parent_id, name, alias, created_at, deleted_at FROM storage_group WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL
`

type GetStorageGroupParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) GetStorageGroup(ctx context.Context, arg GetStorageGroupParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, getStorageGroup, arg.OrgID, arg.ID)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const isItemExists = `-- name: IsItemExists :one
SELECT EXISTS (SELECT 1 FROM item WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL)
`

type IsItemExistsParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) IsItemExists(ctx context.Context, arg IsItemExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isItemExists, arg.OrgID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isOrgExists = `-- name: IsOrgExists :one
SELECT EXISTS (SELECT 1 FROM org WHERE id = $1 AND deleted_at IS NULL)
`

func (q *Queries) IsOrgExists(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isOrgExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isOrgUnitExists = `-- name: IsOrgUnitExists :one
SELECT EXISTS (SELECT 1 FROM org_unit WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL)
`

type IsOrgUnitExistsParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) IsOrgUnitExists(ctx context.Context, arg IsOrgUnitExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isOrgUnitExists, arg.OrgID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isStorageGroupExists = `-- name: IsStorageGroupExists :one
SELECT EXISTS (SELECT 1 FROM storage_group WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL)
`

type IsStorageGroupExistsParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
}

func (q *Queries) IsStorageGroupExists(ctx context.Context, arg IsStorageGroupExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, isStorageGroupExists, arg.OrgID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateItem = `-- name: UpdateItem :one
UPDATE item SET name = $3, description = $4 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, name, description, created_at, deleted_at
`

type UpdateItemParams struct {
	OrgID       pgtype.UUID
	ID          pgtype.UUID
	Name        string
	Description pgtype.Text
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) (Item, error) {
	row := q.db.QueryRow(ctx, updateItem,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Description,
	)
	var i Item
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateItemVariant = `-- name: UpdateItemVariant :one
UPDATE item_variant SET name = $2, article = $3, ean13 = $4 WHERE item_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, item_id, name, article, ean13, created_at, deleted_at
`

type UpdateItemVariantParams struct {
	ItemID  pgtype.UUID
	Name    string
	Article pgtype.Text
	Ean13   pgtype.Int4
}

func (q *Queries) UpdateItemVariant(ctx context.Context, arg UpdateItemVariantParams) (ItemVariant, error) {
	row := q.db.QueryRow(ctx, updateItemVariant,
		arg.ItemID,
		arg.Name,
		arg.Article,
		arg.Ean13,
	)
	var i ItemVariant
	err := row.Scan(
		&i.ID,
		&i.ItemID,
		&i.Name,
		&i.Article,
		&i.Ean13,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateOrg = `-- name: UpdateOrg :one
UPDATE org SET name = $2, subdomain = $3 WHERE id = $1 RETURNING id, name, subdomain, created_at, deleted_at
`

type UpdateOrgParams struct {
	ID        pgtype.UUID
	Name      string
	Subdomain string
}

func (q *Queries) UpdateOrg(ctx context.Context, arg UpdateOrgParams) (Org, error) {
	row := q.db.QueryRow(ctx, updateOrg, arg.ID, arg.Name, arg.Subdomain)
	var i Org
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Subdomain,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateOrgUnit = `-- name: UpdateOrgUnit :one
UPDATE org_unit SET name = $3, alias = $4, address = $5 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, name, alias, address, created_at, deleted_at
`

type UpdateOrgUnitParams struct {
	OrgID   pgtype.UUID
	ID      pgtype.UUID
	Name    string
	Alias   string
	Address pgtype.Text
}

func (q *Queries) UpdateOrgUnit(ctx context.Context, arg UpdateOrgUnitParams) (OrgUnit, error) {
	row := q.db.QueryRow(ctx, updateOrgUnit,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Alias,
		arg.Address,
	)
	var i OrgUnit
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.Name,
		&i.Alias,
		&i.Address,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateStorageGroup = `-- name: UpdateStorageGroup :one
UPDATE storage_group SET name = $3, alias = $4 WHERE org_id = $1 AND id = $2 AND deleted_at IS NULL RETURNING id, org_id, unit_id, parent_id, name, alias, created_at, deleted_at
`

type UpdateStorageGroupParams struct {
	OrgID pgtype.UUID
	ID    pgtype.UUID
	Name  string
	Alias string
}

func (q *Queries) UpdateStorageGroup(ctx context.Context, arg UpdateStorageGroupParams) (StorageGroup, error) {
	row := q.db.QueryRow(ctx, updateStorageGroup,
		arg.OrgID,
		arg.ID,
		arg.Name,
		arg.Alias,
	)
	var i StorageGroup
	err := row.Scan(
		&i.ID,
		&i.OrgID,
		&i.UnitID,
		&i.ParentID,
		&i.Name,
		&i.Alias,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}
