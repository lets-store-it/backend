// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

func recordError(string, error) {}

// handleCreateItemRequest handles createItem operation.
//
// Create Item.
//
// POST /items
func (s *Server) handleCreateItemRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateItemOperation,
			ID:   "createItem",
		}
	)
	request, close, err := s.decodeCreateItemRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CreateItemResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateItemOperation,
			OperationSummary: "Create Item",
			OperationID:      "createItem",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CreateItemRequest
			Params   = struct{}
			Response = *CreateItemResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateItem(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateItem(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeCreateItemResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateOrganizationRequest handles createOrganization operation.
//
// Create Organization.
//
// POST /orgs
func (s *Server) handleCreateOrganizationRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateOrganizationOperation,
			ID:   "createOrganization",
		}
	)
	request, close, err := s.decodeCreateOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CreateOrganizationResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateOrganizationOperation,
			OperationSummary: "Create Organization",
			OperationID:      "createOrganization",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CreateOrganizationRequest
			Params   = struct{}
			Response = *CreateOrganizationResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateOrganization(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateOrganization(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeCreateOrganizationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateStorageGroupRequest handles createStorageGroup operation.
//
// Create Storage Group.
//
// POST /storage-groups
func (s *Server) handleCreateStorageGroupRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateStorageGroupOperation,
			ID:   "createStorageGroup",
		}
	)
	request, close, err := s.decodeCreateStorageGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CreateStorageGroupResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateStorageGroupOperation,
			OperationSummary: "Create Storage Group",
			OperationID:      "createStorageGroup",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CreateStorageGroupRequest
			Params   = struct{}
			Response = *CreateStorageGroupResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateStorageGroup(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateStorageGroup(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeCreateStorageGroupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleCreateUnitRequest handles createUnit operation.
//
// Create Organization Unit.
//
// POST /units
func (s *Server) handleCreateUnitRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: CreateUnitOperation,
			ID:   "createUnit",
		}
	)
	request, close, err := s.decodeCreateUnitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *CreateOrganizationUnitResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    CreateUnitOperation,
			OperationSummary: "Create Organization Unit",
			OperationID:      "createUnit",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *CreateOrganizationUnitRequest
			Params   = struct{}
			Response = *CreateOrganizationUnitResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.CreateUnit(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.CreateUnit(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeCreateUnitResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteItemRequest handles deleteItem operation.
//
// Delete Item.
//
// DELETE /items/{id}
func (s *Server) handleDeleteItemRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteItemOperation,
			ID:   "deleteItem",
		}
	)
	params, err := decodeDeleteItemParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DeleteItemOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteItemOperation,
			OperationSummary: "Delete Item",
			OperationID:      "deleteItem",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteItemParams
			Response = *DeleteItemOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteItemParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.DeleteItem(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.DeleteItem(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeDeleteItemResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteOrganizationRequest handles deleteOrganization operation.
//
// Delete Organization.
//
// DELETE /orgs/{id}
func (s *Server) handleDeleteOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteOrganizationOperation,
			ID:   "deleteOrganization",
		}
	)
	params, err := decodeDeleteOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DeleteOrganizationOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteOrganizationOperation,
			OperationSummary: "Delete Organization",
			OperationID:      "deleteOrganization",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteOrganizationParams
			Response = *DeleteOrganizationOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.DeleteOrganization(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.DeleteOrganization(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeDeleteOrganizationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteOrganizationUnitRequest handles deleteOrganizationUnit operation.
//
// Delete Organization Unit.
//
// DELETE /units/{id}
func (s *Server) handleDeleteOrganizationUnitRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteOrganizationUnitOperation,
			ID:   "deleteOrganizationUnit",
		}
	)
	params, err := decodeDeleteOrganizationUnitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DeleteOrganizationUnitOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteOrganizationUnitOperation,
			OperationSummary: "Delete Organization Unit",
			OperationID:      "deleteOrganizationUnit",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteOrganizationUnitParams
			Response = *DeleteOrganizationUnitOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteOrganizationUnitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.DeleteOrganizationUnit(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.DeleteOrganizationUnit(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeDeleteOrganizationUnitResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleDeleteStorageGroupRequest handles deleteStorageGroup operation.
//
// Delete Storage Group.
//
// DELETE /storage-groups/{id}
func (s *Server) handleDeleteStorageGroupRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: DeleteStorageGroupOperation,
			ID:   "deleteStorageGroup",
		}
	)
	params, err := decodeDeleteStorageGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *DeleteStorageGroupOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    DeleteStorageGroupOperation,
			OperationSummary: "Delete Storage Group",
			OperationID:      "deleteStorageGroup",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = DeleteStorageGroupParams
			Response = *DeleteStorageGroupOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackDeleteStorageGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				err = s.h.DeleteStorageGroup(ctx, params)
				return response, err
			},
		)
	} else {
		err = s.h.DeleteStorageGroup(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeDeleteStorageGroupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleExchangeYandexAccessTokenRequest handles exchangeYandexAccessToken operation.
//
// Exchange Yandex Access token for Session token.
//
// POST /auth/oauth2/yandex
func (s *Server) handleExchangeYandexAccessTokenRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ExchangeYandexAccessTokenOperation,
			ID:   "exchangeYandexAccessToken",
		}
	)
	request, close, err := s.decodeExchangeYandexAccessTokenRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *AuthResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ExchangeYandexAccessTokenOperation,
			OperationSummary: "Exchange Yandex Access token for Session token",
			OperationID:      "exchangeYandexAccessToken",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *ExchangeYandexAccessTokenReq
			Params   = struct{}
			Response = *AuthResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ExchangeYandexAccessToken(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.ExchangeYandexAccessToken(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeExchangeYandexAccessTokenResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetAuthCookieByEmailRequest handles getAuthCookieByEmail operation.
//
// Get Auth Cookie by email.
//
// POST /auth/testing
func (s *Server) handleGetAuthCookieByEmailRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetAuthCookieByEmailOperation,
			ID:   "getAuthCookieByEmail",
		}
	)
	request, close, err := s.decodeGetAuthCookieByEmailRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *GetAuthCookieByEmailOK
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetAuthCookieByEmailOperation,
			OperationSummary: "Get Auth Cookie by email",
			OperationID:      "getAuthCookieByEmail",
			Body:             request,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *GetAuthCookieByEmailRequest
			Params   = struct{}
			Response = *GetAuthCookieByEmailOK
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetAuthCookieByEmail(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetAuthCookieByEmail(ctx, request)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetAuthCookieByEmailResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetCurrentUserRequest handles getCurrentUser operation.
//
// Get Current User.
//
// GET /me
func (s *Server) handleGetCurrentUserRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err error
	)

	var response *GetCurrentUserResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetCurrentUserOperation,
			OperationSummary: "Get Current User",
			OperationID:      "getCurrentUser",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetCurrentUserResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetCurrentUser(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetCurrentUser(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetCurrentUserResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetItemByIdRequest handles getItemById operation.
//
// Get Item by ID.
//
// GET /items/{id}
func (s *Server) handleGetItemByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetItemByIdOperation,
			ID:   "getItemById",
		}
	)
	params, err := decodeGetItemByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetItemByIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetItemByIdOperation,
			OperationSummary: "Get Item by ID",
			OperationID:      "getItemById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetItemByIdParams
			Response = *GetItemByIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetItemByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetItemById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetItemById(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetItemByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetItemsRequest handles getItems operation.
//
// Get list of Items.
//
// GET /items
func (s *Server) handleGetItemsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err error
	)

	var response *GetItemsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetItemsOperation,
			OperationSummary: "Get list of Items",
			OperationID:      "getItems",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetItemsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetItems(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetItems(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetItemsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetOrganizationByIdRequest handles getOrganizationById operation.
//
// Get Organization by ID.
//
// GET /orgs/{id}
func (s *Server) handleGetOrganizationByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetOrganizationByIdOperation,
			ID:   "getOrganizationById",
		}
	)
	params, err := decodeGetOrganizationByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetOrganizationByIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetOrganizationByIdOperation,
			OperationSummary: "Get Organization by ID",
			OperationID:      "getOrganizationById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetOrganizationByIdParams
			Response = *GetOrganizationByIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetOrganizationByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetOrganizationById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetOrganizationById(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetOrganizationByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetOrganizationUnitByIdRequest handles getOrganizationUnitById operation.
//
// Get Unit by ID.
//
// GET /units/{id}
func (s *Server) handleGetOrganizationUnitByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetOrganizationUnitByIdOperation,
			ID:   "getOrganizationUnitById",
		}
	)
	params, err := decodeGetOrganizationUnitByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetOrganizationUnitByIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetOrganizationUnitByIdOperation,
			OperationSummary: "Get Unit by ID",
			OperationID:      "getOrganizationUnitById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetOrganizationUnitByIdParams
			Response = *GetOrganizationUnitByIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetOrganizationUnitByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetOrganizationUnitById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetOrganizationUnitById(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetOrganizationUnitByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetOrganizationUnitsRequest handles getOrganizationUnits operation.
//
// Get list of Organization Units.
//
// GET /units
func (s *Server) handleGetOrganizationUnitsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err error
	)

	var response *GetOrganizationUnitsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetOrganizationUnitsOperation,
			OperationSummary: "Get list of Organization Units",
			OperationID:      "getOrganizationUnits",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetOrganizationUnitsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetOrganizationUnits(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetOrganizationUnits(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetOrganizationUnitsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetOrganizationsRequest handles getOrganizations operation.
//
// Get list of Organizations.
//
// GET /orgs
func (s *Server) handleGetOrganizationsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err error
	)

	var response *GetOrganizationsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetOrganizationsOperation,
			OperationSummary: "Get list of Organizations",
			OperationID:      "getOrganizations",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetOrganizationsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetOrganizations(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetOrganizations(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetOrganizationsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageGroupByIdRequest handles getStorageGroupById operation.
//
// Get Storage Group by ID.
//
// GET /storage-groups/{id}
func (s *Server) handleGetStorageGroupByIdRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: GetStorageGroupByIdOperation,
			ID:   "getStorageGroupById",
		}
	)
	params, err := decodeGetStorageGroupByIdParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var response *GetStorageGroupByIdResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetStorageGroupByIdOperation,
			OperationSummary: "Get Storage Group by ID",
			OperationID:      "getStorageGroupById",
			Body:             nil,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = GetStorageGroupByIdParams
			Response = *GetStorageGroupByIdResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackGetStorageGroupByIdParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageGroupById(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageGroupById(ctx, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStorageGroupByIdResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleGetStorageGroupsRequest handles getStorageGroups operation.
//
// Get list of Storage Groups.
//
// GET /storage-groups
func (s *Server) handleGetStorageGroupsRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err error
	)

	var response *GetStorageGroupsResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    GetStorageGroupsOperation,
			OperationSummary: "Get list of Storage Groups",
			OperationID:      "getStorageGroups",
			Body:             nil,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = struct{}
			Params   = struct{}
			Response = *GetStorageGroupsResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.GetStorageGroups(ctx)
				return response, err
			},
		)
	} else {
		response, err = s.h.GetStorageGroups(ctx)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeGetStorageGroupsResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchItemRequest handles patchItem operation.
//
// Patch Item.
//
// PATCH /items/{id}
func (s *Server) handlePatchItemRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PatchItemOperation,
			ID:   "patchItem",
		}
	)
	params, err := decodePatchItemParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchItemRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PatchItemResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PatchItemOperation,
			OperationSummary: "Patch Item",
			OperationID:      "patchItem",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *PatchItemRequest
			Params   = PatchItemParams
			Response = *PatchItemResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchItemParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchItem(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchItem(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodePatchItemResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchOrganizationRequest handles patchOrganization operation.
//
// Update Organization.
//
// PATCH /orgs/{id}
func (s *Server) handlePatchOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PatchOrganizationOperation,
			ID:   "patchOrganization",
		}
	)
	params, err := decodePatchOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PatchOrganizationResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PatchOrganizationOperation,
			OperationSummary: "Update Organization",
			OperationID:      "patchOrganization",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *PatchOrganizationRequest
			Params   = PatchOrganizationParams
			Response = *PatchOrganizationResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchOrganization(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodePatchOrganizationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchOrganizationUnitRequest handles patchOrganizationUnit operation.
//
// Patch Organization Unit.
//
// PATCH /units/{id}
func (s *Server) handlePatchOrganizationUnitRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PatchOrganizationUnitOperation,
			ID:   "patchOrganizationUnit",
		}
	)
	params, err := decodePatchOrganizationUnitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchOrganizationUnitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PatchOrganizationUnitResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PatchOrganizationUnitOperation,
			OperationSummary: "Patch Organization Unit",
			OperationID:      "patchOrganizationUnit",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *PatchOrganizationUnitRequest
			Params   = PatchOrganizationUnitParams
			Response = *PatchOrganizationUnitResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchOrganizationUnitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchOrganizationUnit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchOrganizationUnit(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodePatchOrganizationUnitResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handlePatchStorageGroupRequest handles patchStorageGroup operation.
//
// Patch Storage Group.
//
// PATCH /storage-groups/{id}
func (s *Server) handlePatchStorageGroupRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: PatchStorageGroupOperation,
			ID:   "patchStorageGroup",
		}
	)
	params, err := decodePatchStorageGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodePatchStorageGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *PatchStorageGroupResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    PatchStorageGroupOperation,
			OperationSummary: "Patch Storage Group",
			OperationID:      "patchStorageGroup",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *PatchStorageGroupRequest
			Params   = PatchStorageGroupParams
			Response = *PatchStorageGroupResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackPatchStorageGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.PatchStorageGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.PatchStorageGroup(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodePatchStorageGroupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateItemRequest handles updateItem operation.
//
// Update Item.
//
// PUT /items/{id}
func (s *Server) handleUpdateItemRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateItemOperation,
			ID:   "updateItem",
		}
	)
	params, err := decodeUpdateItemParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateItemRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *UpdateItemResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateItemOperation,
			OperationSummary: "Update Item",
			OperationID:      "updateItem",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *UpdateItemRequest
			Params   = UpdateItemParams
			Response = *UpdateItemResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateItemParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateItem(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateItem(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeUpdateItemResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateOrganizationRequest handles updateOrganization operation.
//
// Update Organization.
//
// PUT /orgs/{id}
func (s *Server) handleUpdateOrganizationRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateOrganizationOperation,
			ID:   "updateOrganization",
		}
	)
	params, err := decodeUpdateOrganizationParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateOrganizationRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *UpdateOrganizationResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateOrganizationOperation,
			OperationSummary: "Update Organization",
			OperationID:      "updateOrganization",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *UpdateOrganizationRequest
			Params   = UpdateOrganizationParams
			Response = *UpdateOrganizationResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateOrganizationParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateOrganization(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateOrganization(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeUpdateOrganizationResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateOrganizationUnitRequest handles updateOrganizationUnit operation.
//
// Update Organization Unit.
//
// PUT /units/{id}
func (s *Server) handleUpdateOrganizationUnitRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateOrganizationUnitOperation,
			ID:   "updateOrganizationUnit",
		}
	)
	params, err := decodeUpdateOrganizationUnitParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateOrganizationUnitRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *UpdateOrganizationUnitResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateOrganizationUnitOperation,
			OperationSummary: "Update Organization Unit",
			OperationID:      "updateOrganizationUnit",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *UpdateOrganizationUnitRequest
			Params   = UpdateOrganizationUnitParams
			Response = *UpdateOrganizationUnitResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateOrganizationUnitParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateOrganizationUnit(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateOrganizationUnit(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeUpdateOrganizationUnitResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUpdateStorageGroupRequest handles updateStorageGroup operation.
//
// Update Storage Group.
//
// PUT /storage-groups/{id}
func (s *Server) handleUpdateStorageGroupRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UpdateStorageGroupOperation,
			ID:   "updateStorageGroup",
		}
	)
	params, err := decodeUpdateStorageGroupParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	request, close, err := s.decodeUpdateStorageGroupRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response *UpdateStorageGroupResponse
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UpdateStorageGroupOperation,
			OperationSummary: "Update Storage Group",
			OperationID:      "updateStorageGroup",
			Body:             request,
			Params: middleware.Parameters{
				{
					Name: "id",
					In:   "path",
				}: params.ID,
			},
			Raw: r,
		}

		type (
			Request  = *UpdateStorageGroupRequest
			Params   = UpdateStorageGroupParams
			Response = *UpdateStorageGroupResponse
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUpdateStorageGroupParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UpdateStorageGroup(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UpdateStorageGroup(ctx, request, params)
	}
	if err != nil {
		if errRes, ok := errors.Into[*DefaultErrorStatusCode](err); ok {
			if err := encodeErrorResponse(errRes, w); err != nil {
				defer recordError("Internal", err)
			}
			return
		}
		if errors.Is(err, ht.ErrNotImplemented) {
			s.cfg.ErrorHandler(ctx, w, r, err)
			return
		}
		if err := encodeErrorResponse(s.h.NewError(ctx, err), w); err != nil {
			defer recordError("Internal", err)
		}
		return
	}

	if err := encodeUpdateStorageGroupResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
